{"ast":null,"code":"'use strict';\n\nconst stringWidth = require('string-width');\n\nconst stripAnsi = require('strip-ansi');\n\nconst wrap = require('wrap-ansi');\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\n\nclass UI {\n  constructor(opts) {\n    this.width = opts.width;\n    this.wrap = opts.wrap;\n    this.rows = [];\n  }\n\n  span() {\n    const cols = this.div(...arguments);\n    cols.span = true;\n  }\n\n  resetOutput() {\n    this.rows = [];\n  }\n\n  div() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 0) {\n      this.div('');\n    }\n\n    if (this.wrap && this._shouldApplyLayoutDSL(...args)) {\n      return this._applyLayoutDSL(args[0]);\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this._colFromString(arg);\n      }\n\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n\n  _shouldApplyLayoutDSL() {\n    return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\\t\\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n\n  _applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0; // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n\n    rows.forEach(columns => {\n      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), stringWidth(columns[0]));\n      }\n    }); // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this._measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n\n  _colFromString(text) {\n    return {\n      text,\n      padding: this._measurePadding(text)\n    };\n  }\n\n  _measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    }); // don't display any lines with the\n    // hidden flag set.\n\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n\n  rowToString(row, lines) {\n    this._rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n\n        const wrapWidth = this._negatePadding(row[c]); // the width without padding.\n\n\n        let ts = col; // temporary string used during alignment/padding.\n\n        if (wrapWidth > stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - stringWidth(col));\n        } // align the string within its column.\n\n\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          ts = align[row[c].align](ts, wrapWidth);\n\n          if (stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat(width - stringWidth(ts) - 1);\n          }\n        } // apply border and padding to string.\n\n\n        const padding = row[c].padding || [0, 0, 0, 0];\n\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        } // if prior row is span, try to render the\n        // current row on the prior line.\n\n\n        if (r === 0 && lines.length > 0) {\n          str = this._renderInline(str, lines[lines.length - 1]);\n        }\n      }); // remove trailing whitespace.\n\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n\n    return lines;\n  } // if the full 'source' can render in\n  // the target line, do so.\n\n\n  _renderInline(source, previousLine) {\n    const leadingWhitespace = source.match(/^ */)[0].length;\n    const target = previousLine.text;\n    const targetTextWidth = stringWidth(target.trimRight());\n\n    if (!previousLine.span) {\n      return source;\n    } // if we're not applying wrapping logic,\n    // just always append to the span.\n\n\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n\n    previousLine.hidden = true;\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n  }\n\n  _rasterize(row) {\n    const rrows = [];\n\n    const widths = this._columnWidths(row);\n\n    let wrapped; // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n\n      if (this.wrap) {\n        wrapped = wrap(col.text, this._negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this._negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this._negatePadding(col) + 2) + \"'\");\n      } // add top and bottom padding.\n\n\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n\n        const rrow = rrows[r];\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n\n  _negatePadding(col) {\n    let wrapWidth = col.width;\n\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n\n    return wrapWidth;\n  }\n\n  _columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || stringWidth(col.text);\n      });\n    }\n\n    let unset = row.length;\n    let remainingWidth = this.width; // column widths can be set in config.\n\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n\n      return undefined;\n    }); // any unset widths should be calculated.\n\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n\n      return w;\n    });\n  }\n\n}\n\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n\n    return '  ';\n  }\n\n  return '';\n} // calculates the minimum width of\n// a column, based on padding preferences.\n\n\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n\n  if (col.border) {\n    return minWidth + 4;\n  }\n\n  return minWidth;\n}\n\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n}\n\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = stringWidth(str);\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n\n  return str;\n}\n\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = stringWidth(str);\n  /* istanbul ignore next */\n\n  if (strWidth >= width) {\n    return str;\n  }\n\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\n\nmodule.exports = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new UI({\n    width: opts.width || getWindowWidth() ||\n    /* istanbul ignore next */\n    80,\n    wrap: opts.wrap !== false\n  });\n};","map":{"version":3,"names":["stringWidth","require","stripAnsi","wrap","align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","width","rows","span","cols","div","resetOutput","args","length","_shouldApplyLayoutDSL","_applyLayoutDSL","map","arg","_colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","Math","min","floor","r","i","text","trim","padding","_measurePadding","undefined","noAnsi","match","toString","lines","rowToString","filter","line","hidden","join","_rasterize","rrow","col","c","wrapWidth","_negatePadding","ts","repeat","addBorder","_renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","_columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","module","exports"],"sources":["/home/portuga/trybe-projetos/sd-021-b-project-trybewallet/node_modules/cliui/index.js"],"sourcesContent":["'use strict'\n\nconst stringWidth = require('string-width')\nconst stripAnsi = require('strip-ansi')\nconst wrap = require('wrap-ansi')\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n}\nconst top = 0\nconst right = 1\nconst bottom = 2\nconst left = 3\n\nclass UI {\n  constructor (opts) {\n    this.width = opts.width\n    this.wrap = opts.wrap\n    this.rows = []\n  }\n\n  span (...args) {\n    const cols = this.div(...args)\n    cols.span = true\n  }\n\n  resetOutput () {\n    this.rows = []\n  }\n\n  div (...args) {\n    if (args.length === 0) {\n      this.div('')\n    }\n\n    if (this.wrap && this._shouldApplyLayoutDSL(...args)) {\n      return this._applyLayoutDSL(args[0])\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this._colFromString(arg)\n      }\n\n      return arg\n    })\n\n    this.rows.push(cols)\n    return cols\n  }\n\n  _shouldApplyLayoutDSL (...args) {\n    return args.length === 1 && typeof args[0] === 'string' &&\n      /[\\t\\n]/.test(args[0])\n  }\n\n  _applyLayoutDSL (str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'))\n    let leftColumnWidth = 0\n\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(\n          Math.floor(this.width * 0.5),\n          stringWidth(columns[0])\n        )\n      }\n    })\n\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this._measurePadding(r),\n          width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n        }\n      }))\n    })\n\n    return this.rows[this.rows.length - 1]\n  }\n\n  _colFromString (text) {\n    return {\n      text,\n      padding: this._measurePadding(text)\n    }\n  }\n\n  _measurePadding (str) {\n    // measure padding without ansi escape codes\n    const noAnsi = stripAnsi(str)\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length]\n  }\n\n  toString () {\n    const lines = []\n\n    this.rows.forEach(row => {\n      this.rowToString(row, lines)\n    })\n\n    // don't display any lines with the\n    // hidden flag set.\n    return lines\n      .filter(line => !line.hidden)\n      .map(line => line.text)\n      .join('\\n')\n  }\n\n  rowToString (row, lines) {\n    this._rasterize(row).forEach((rrow, r) => {\n      let str = ''\n      rrow.forEach((col, c) => {\n        const { width } = row[c] // the width with padding.\n        const wrapWidth = this._negatePadding(row[c]) // the width without padding.\n\n        let ts = col // temporary string used during alignment/padding.\n\n        if (wrapWidth > stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - stringWidth(col))\n        }\n\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          ts = align[row[c].align](ts, wrapWidth)\n          if (stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat(width - stringWidth(ts) - 1)\n          }\n        }\n\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0]\n        if (padding[left]) {\n          str += ' '.repeat(padding[left])\n        }\n\n        str += addBorder(row[c], ts, '| ')\n        str += ts\n        str += addBorder(row[c], ts, ' |')\n        if (padding[right]) {\n          str += ' '.repeat(padding[right])\n        }\n\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this._renderInline(str, lines[lines.length - 1])\n        }\n      })\n\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      })\n    })\n\n    return lines\n  }\n\n  // if the full 'source' can render in\n  // the target line, do so.\n  _renderInline (source, previousLine) {\n    const leadingWhitespace = source.match(/^ */)[0].length\n    const target = previousLine.text\n    const targetTextWidth = stringWidth(target.trimRight())\n\n    if (!previousLine.span) {\n      return source\n    }\n\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true\n      return target + source\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source\n    }\n\n    previousLine.hidden = true\n\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft()\n  }\n\n  _rasterize (row) {\n    const rrows = []\n    const widths = this._columnWidths(row)\n    let wrapped\n\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c]\n      if (this.wrap) {\n        wrapped = wrap(col.text, this._negatePadding(col), { hard: true }).split('\\n')\n      } else {\n        wrapped = col.text.split('\\n')\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this._negatePadding(col) + 2) + '.')\n        wrapped.push(\"'\" + '-'.repeat(this._negatePadding(col) + 2) + \"'\")\n      }\n\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''))\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''))\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([])\n        }\n\n        const rrow = rrows[r]\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('')\n          }\n        }\n\n        rrow.push(str)\n      })\n    })\n\n    return rrows\n  }\n\n  _negatePadding (col) {\n    let wrapWidth = col.width\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)\n    }\n\n    if (col.border) {\n      wrapWidth -= 4\n    }\n\n    return wrapWidth\n  }\n\n  _columnWidths (row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || stringWidth(col.text)\n      })\n    }\n\n    let unset = row.length\n    let remainingWidth = this.width\n\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--\n        remainingWidth -= col.width\n        return col.width\n      }\n\n      return undefined\n    })\n\n    // any unset widths should be calculated.\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0\n\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]))\n      }\n\n      return w\n    })\n  }\n}\n\nfunction addBorder (col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return ''\n    }\n\n    if (ts.trim().length !== 0) {\n      return style\n    }\n\n    return '  '\n  }\n\n  return ''\n}\n\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth (col) {\n  const padding = col.padding || []\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)\n  if (col.border) {\n    return minWidth + 4\n  }\n\n  return minWidth\n}\n\nfunction getWindowWidth () {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns\n  }\n}\n\nfunction alignRight (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str\n  }\n\n  return str\n}\n\nfunction alignCenter (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  /* istanbul ignore next */\n  if (strWidth >= width) {\n    return str\n  }\n\n  return ' '.repeat((width - strWidth) >> 1) + str\n}\n\nmodule.exports = function (opts = {}) {\n  return new UI({\n    width: opts.width || getWindowWidth() || /* istanbul ignore next */ 80,\n    wrap: opts.wrap !== false\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}