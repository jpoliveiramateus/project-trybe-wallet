{"ast":null,"code":"const camelCase = require('camelcase');\n\nconst decamelize = require('decamelize');\n\nconst path = require('path');\n\nconst tokenizeArgString = require('./lib/tokenize-arg-string');\n\nconst util = require('util');\n\nfunction parse(args, opts) {\n  opts = Object.assign(Object.create(null), opts); // allow a string argument to be passed in rather\n  // than an argv array.\n\n  args = tokenizeArgString(args); // aliases might have transitive relationships, normalize this.\n\n  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n  const configuration = Object.assign({\n    'boolean-negation': true,\n    'camel-case-expansion': true,\n    'combine-arrays': false,\n    'dot-notation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'greedy-arrays': true,\n    'halt-at-non-option': false,\n    'nargs-eats-options': false,\n    'negation-prefix': 'no-',\n    'parse-numbers': true,\n    'populate--': false,\n    'set-placeholder-key': false,\n    'short-option-groups': true,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration);\n  const defaults = Object.assign(Object.create(null), opts.default);\n  const configObjects = opts.configObjects || [];\n  const envPrefix = opts.envPrefix;\n  const notFlagsOption = configuration['populate--'];\n  const notFlagsArgv = notFlagsOption ? '--' : '_';\n  const newAliases = Object.create(null);\n  const defaulted = Object.create(null); // allow a i18n handler to be passed in, default to a fake one (util.format).\n\n  const __ = opts.__ || util.format;\n\n  const flags = {\n    aliases: Object.create(null),\n    arrays: Object.create(null),\n    bools: Object.create(null),\n    strings: Object.create(null),\n    numbers: Object.create(null),\n    counts: Object.create(null),\n    normalize: Object.create(null),\n    configs: Object.create(null),\n    nargs: Object.create(null),\n    coercions: Object.create(null),\n    keys: []\n  };\n  const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n  [].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    const key = opt.key || opt; // assign to flags[bools|strings|numbers]\n\n    const assignment = Object.keys(opt).map(function (key) {\n      return {\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      }[key];\n    }).filter(Boolean).pop(); // assign key to be coerced\n\n    if (assignment) {\n      flags[assignment][key] = true;\n    }\n\n    flags.arrays[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true;\n    flags.keys.push(key);\n  });\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k];\n    flags.keys.push(k);\n  });\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k];\n    flags.keys.push(k);\n  });\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;\n    [].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true;\n    });\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k];\n    });\n  } // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n\n\n  extendAliases(opts.key, aliases, opts.default, flags.arrays); // apply default values to all aliases.\n\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key];\n    });\n  });\n  let error = null;\n  checkConfiguration();\n  let notFlags = [];\n  const argv = Object.assign(Object.create(null), {\n    _: []\n  }); // TODO(bcoe): for the first pass at removing object prototype  we didn't\n  // remove all prototypes from objects returned by this API, we might want\n  // to gradually move towards doing so.\n\n  const argvReturn = {};\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    let broken;\n    let key;\n    let letters;\n    let m;\n    let next;\n    let value; // any unknown option (except for end-of-options, \"--\")\n\n    if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n      argv._.push(arg); // -- separated by =\n\n    } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/); // arrays format = '--f=a b c'\n\n      if (checkAllAliases(m[1], flags.arrays)) {\n        i = eatArray(i, m[1], args, m[2]);\n      } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n        // nargs format = '--f=monkey washing cat'\n        i = eatNargs(i, m[1], args, m[2]);\n      } else {\n        setArg(m[1], m[2]);\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1];\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false); // -- separated by space.\n    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n      key = arg.match(/^--?(.+)/)[1];\n\n      if (checkAllAliases(key, flags.arrays)) {\n        // array format = '--foo a b c'\n        i = eatArray(i, key, args);\n      } else if (checkAllAliases(key, flags.nargs) !== false) {\n        // nargs format = '--foo a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        i = eatNargs(i, key, args);\n      } else {\n        next = args[i + 1];\n\n        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n          setArg(key, next);\n          i++;\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next);\n          i++;\n        } else {\n          setArg(key, defaultValue(key));\n        }\n      } // dot-notation flag separated by '='.\n\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n      setArg(m[1], m[2]); // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n      next = args[i + 1];\n      key = arg.match(/^-(.\\..+)/)[1];\n\n      if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n        setArg(key, next);\n        i++;\n      } else {\n        setArg(key, defaultValue(key));\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('');\n      broken = false;\n\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3);\n          key = letters[j];\n\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '-f=a b c'\n            i = eatArray(i, key, args, value);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '-f=monkey washing cat'\n            i = eatNargs(i, key, args, value);\n          } else {\n            setArg(key, value);\n          }\n\n          broken = true;\n          break;\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next);\n          continue;\n        } // current letter is an alphabetic character and next value is a number\n\n\n        if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        } else {\n          setArg(letters[j], defaultValue(letters[j]));\n        }\n      }\n\n      key = arg.slice(-1)[0];\n\n      if (!broken && key !== '-') {\n        if (checkAllAliases(key, flags.arrays)) {\n          // array format = '-f a b c'\n          i = eatArray(i, key, args);\n        } else if (checkAllAliases(key, flags.nargs) !== false) {\n          // nargs format = '-f a b c'\n          // should be truthy even if: flags.nargs[key] === 0\n          i = eatNargs(i, key, args);\n        } else {\n          next = args[i + 1];\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultValue(key));\n          }\n        }\n      }\n    } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n      // single-digit boolean alias, e.g: xargs -0\n      key = arg.slice(1);\n      setArg(key, defaultValue(key));\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1);\n      break;\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i);\n      break;\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg));\n    }\n  } // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n\n\n  applyEnvVars(argv, true); // special case: check env vars that point to config file\n\n  applyEnvVars(argv, false);\n  setConfig(argv);\n  setConfigObjects();\n  applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n  applyCoercions(argv);\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv); // for any counts either not in args or without an explicit default, set to 0\n\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n  }); // '--' defaults to undefined.\n\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key);\n  });\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key];\n    });\n  }\n\n  if (configuration['strip-aliased']) {\n    ;\n    [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n      }\n\n      delete argv[alias];\n    });\n  } // how many arguments should we consume, based\n  // on the nargs option?\n\n\n  function eatNargs(i, key, args, argAfterEqualSign) {\n    let ii;\n    let toEat = checkAllAliases(key, flags.nargs); // NaN has a special meaning for the array type, indicating that one or\n    // more values are expected.\n\n    toEat = isNaN(toEat) ? 1 : toEat;\n\n    if (toEat === 0) {\n      if (!isUndefined(argAfterEqualSign)) {\n        error = Error(__('Argument unexpected for: %s', key));\n      }\n\n      setArg(key, defaultValue(key));\n      return i;\n    }\n\n    let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n\n    if (configuration['nargs-eats-options']) {\n      // classic behavior, yargs eats positional and dash arguments.\n      if (args.length - (i + 1) + available < toEat) {\n        error = Error(__('Not enough arguments following: %s', key));\n      }\n\n      available = toEat;\n    } else {\n      // nargs will not consume flag arguments, e.g., -abc, --foo,\n      // and terminates when one is observed.\n      for (ii = i + 1; ii < args.length; ii++) {\n        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;\n      }\n\n      if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n    }\n\n    let consumed = Math.min(available, toEat);\n\n    if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n      setArg(key, argAfterEqualSign);\n      consumed--;\n    }\n\n    for (ii = i + 1; ii < consumed + i + 1; ii++) {\n      setArg(key, args[ii]);\n    }\n\n    return i + consumed;\n  } // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n\n\n  function eatArray(i, key, args, argAfterEqualSign) {\n    let argsToSet = [];\n    let next = argAfterEqualSign || args[i + 1]; // If both array and nargs are configured, enforce the nargs count:\n\n    const nargsCount = checkAllAliases(key, flags.nargs);\n\n    if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n      argsToSet.push(true);\n    } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults[key] !== undefined) {\n        const defVal = defaults[key];\n        argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n      }\n    } else {\n      // value in --option=value is eaten as is\n      if (!isUndefined(argAfterEqualSign)) {\n        argsToSet.push(processValue(key, argAfterEqualSign));\n      }\n\n      for (let ii = i + 1; ii < args.length; ii++) {\n        if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && argsToSet.length >= nargsCount) break;\n        next = args[ii];\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n        i = ii;\n        argsToSet.push(processValue(key, next));\n      }\n    } // If both array and nargs are configured, create an error if less than\n    // nargs positionals were found. NaN has special meaning, indicating\n    // that at least one value is required (more are okay).\n\n\n    if (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0) {\n      error = Error(__('Not enough arguments following: %s', key));\n    }\n\n    setArg(key, argsToSet);\n    return i;\n  }\n\n  function setArg(key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      const alias = key.split('.').map(function (prop) {\n        return camelCase(prop);\n      }).join('.');\n      addNewAlias(key, alias);\n    }\n\n    const value = processValue(key, val);\n    const splitKey = key.split('.');\n    setKey(argv, splitKey, value); // handle populating aliases of the full key\n\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.');\n        setKey(argv, x, value);\n      });\n    } // handle populating aliases of the first element of the dot-notation key\n\n\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;\n      (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.'); // expand alias with nested objects in key\n\n        const a = [].concat(splitKey);\n        a.shift(); // nuke the old key.\n\n        x = x.concat(a); // populate alias only if is not already an alias of the full key\n        // (already populated above)\n\n        if (!(flags.aliases[key] || []).includes(x.join('.'))) {\n          setKey(argv, x, value);\n        }\n      });\n    } // Set normalize getter and setter when key is in 'normalize' but isn't an array\n\n\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      const keys = [key].concat(flags.aliases[key] || []);\n      keys.forEach(function (key) {\n        Object.defineProperty(argvReturn, key, {\n          enumerable: true,\n\n          get() {\n            return val;\n          },\n\n          set(value) {\n            val = typeof value === 'string' ? path.normalize(value) : value;\n          }\n\n        });\n      });\n    }\n  }\n\n  function addNewAlias(key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias];\n      newAliases[alias] = true;\n    }\n\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key);\n    }\n  }\n\n  function processValue(key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0]) {\n      val = val.substring(1, val.length - 1);\n    } // handle parsing boolean arguments --foo=true --bar false.\n\n\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true';\n    }\n\n    let value = Array.isArray(val) ? val.map(function (v) {\n      return maybeCoerceNumber(key, v);\n    }) : maybeCoerceNumber(key, val); // increment a count given as arg (either no value or value parsed as boolean)\n\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment;\n    } // Set normalized value when key is in 'normalize' and in 'arrays'\n\n\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize);else value = path.normalize(val);\n    }\n\n    return value;\n  }\n\n  function maybeCoerceNumber(key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(value));\n      if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) value = Number(value);\n    }\n\n    return value;\n  } // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n\n\n  function setConfig(argv) {\n    const configLookup = Object.create(null); // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n    Object.keys(flags.configs).forEach(function (configKey) {\n      const configPath = argv[configKey] || configLookup[configKey];\n\n      if (configPath) {\n        try {\n          let config = null;\n          const resolvedConfigPath = path.resolve(process.cwd(), configPath);\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath);\n            } catch (e) {\n              config = e;\n            }\n\n            if (config instanceof Error) {\n              error = config;\n              return;\n            }\n          } else {\n            config = require(resolvedConfigPath);\n          }\n\n          setConfigObject(config);\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n        }\n      }\n    });\n  } // set args from config object.\n  // it recursively checks nested objects.\n\n\n  function setConfigObject(config, prev) {\n    Object.keys(config).forEach(function (key) {\n      const value = config[key];\n      const fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey);\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n          setArg(fullKey, value);\n        }\n      }\n    });\n  } // set all config objects passed in opts\n\n\n  function setConfigObjects() {\n    if (typeof configObjects === 'undefined') return;\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject);\n    });\n  }\n\n  function applyEnvVars(argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return;\n    const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        const keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length);\n          }\n\n          return camelCase(key);\n        });\n\n        if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar]);\n        }\n      }\n    });\n  }\n\n  function applyCoercions(argv) {\n    let coerce;\n    const applied = new Set();\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.has(key)) {\n        // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions);\n\n        if (typeof coerce === 'function') {\n          try {\n            const value = maybeCoerceNumber(key, coerce(argv[key]));\n            [].concat(flags.aliases[key] || [], key).forEach(ali => {\n              applied.add(ali);\n              argv[ali] = value;\n            });\n          } catch (err) {\n            error = err;\n          }\n        }\n      }\n    });\n  }\n\n  function setPlaceholderKeys(argv) {\n    flags.keys.forEach(key => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return;\n      if (typeof argv[key] === 'undefined') argv[key] = undefined;\n    });\n    return argv;\n  }\n\n  function applyDefaultsAndAliases(obj, aliases, defaults) {\n    let canLog = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key]);\n        if (canLog) defaulted[key] = true;\n        (aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return;\n          setKey(obj, x.split('.'), defaults[key]);\n        });\n      }\n    });\n  }\n\n  function hasKey(obj, keys) {\n    let o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      o = o[key] || {};\n    });\n    const key = keys[keys.length - 1];\n    if (typeof o !== 'object') return false;else return key in o;\n  }\n\n  function setKey(obj, keys, value) {\n    let o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key);\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {};\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({});\n        } else {\n          o[key] = [o[key], {}];\n        } // we want to update the empty object at the end of the o[key] array, so set o to that object\n\n\n        o = o[key][o[key].length - 1];\n      } else {\n        o = o[key];\n      }\n    }); // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n\n    const key = sanitizeKey(keys[keys.length - 1]);\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n    const isValueArray = Array.isArray(value);\n    let duplicate = configuration['duplicate-arguments-array']; // nargs has higher priority than duplicate\n\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true;\n\n      if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n        o[key] = undefined;\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key]);\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value;\n      } else {\n        o[key] = o[key].concat([value]);\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value];\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n      o[key] = [o[key], value];\n    } else {\n      o[key] = value;\n    }\n  } // extend the aliases list with inferred aliases.\n\n\n  function extendAliases() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return;\n        flags.aliases[key] = [].concat(aliases[key] || []); // For \"--option-name\", also set argv.optionName\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            const c = camelCase(x);\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        }); // For \"--optionName\", also set argv['option-name']\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            const c = decamelize(x, '-');\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        });\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y;\n          }));\n        });\n      });\n    });\n  } // return the 1st set flag for any of a key's aliases (or false if no flag set)\n\n\n  function checkAllAliases(key, flag) {\n    const toCheck = [].concat(flags.aliases[key] || [], key);\n    const keys = Object.keys(flag);\n    const setAlias = toCheck.find(key => keys.includes(key));\n    return setAlias ? flag[setAlias] : false;\n  }\n\n  function hasAnyFlag(key) {\n    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]));\n    return toCheck.some(function (flag) {\n      return Array.isArray(flag) ? flag.includes(key) : flag[key];\n    });\n  }\n\n  function hasFlagsMatching(arg) {\n    for (var _len2 = arguments.length, patterns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      patterns[_key2 - 1] = arguments[_key2];\n    }\n\n    const toCheck = [].concat(...patterns);\n    return toCheck.some(function (pattern) {\n      const match = arg.match(pattern);\n      return match && hasAnyFlag(match[1]);\n    });\n  } // based on a simplified version of the short flag group parsing logic\n\n\n  function hasAllShortFlags(arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n      return false;\n    }\n\n    let hasAllFlags = true;\n    let next;\n    const letters = arg.slice(1).split('');\n\n    for (let j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2);\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false;\n        break;\n      }\n\n      if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n        break;\n      }\n    }\n\n    return hasAllFlags;\n  }\n\n  function isUnknownOptionAsArg(arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n  }\n\n  function isUnknownOption(arg) {\n    // ignore negative numbers\n    if (arg.match(negative)) {\n      return false;\n    } // if this is a short option group and all of them are configured, it isn't unknown\n\n\n    if (hasAllShortFlags(arg)) {\n      return false;\n    } // e.g. '--count=2'\n\n\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/; // e.g. '-a' or '--arg'\n\n    const normalFlag = /^-+([^=]+?)$/; // e.g. '-a-'\n\n    const flagEndingInHyphen = /^-+([^=]+?)-$/; // e.g. '-abc123'\n\n    const flagEndingInDigits = /^-+([^=]+?\\d+)$/; // e.g. '-a/usr/local'\n\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/; // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n  } // make a best effor to pick a default value\n  // for an option based on name and type.\n\n\n  function defaultValue(key) {\n    if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n      return defaults[key];\n    } else {\n      return defaultForType(guessType(key));\n    }\n  } // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n\n\n  function defaultForType(type) {\n    const def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    };\n    return def[type];\n  } // given a flag, enforce a default type.\n\n\n  function guessType(key) {\n    let type = 'boolean';\n    if (checkAllAliases(key, flags.strings)) type = 'string';else if (checkAllAliases(key, flags.numbers)) type = 'number';else if (checkAllAliases(key, flags.bools)) type = 'boolean';else if (checkAllAliases(key, flags.arrays)) type = 'array';\n    return type;\n  }\n\n  function isNumber(x) {\n    if (x === null || x === undefined) return false; // if loaded from config, may already be a number.\n\n    if (typeof x === 'number') return true; // hexadecimal.\n\n    if (/^0x[0-9a-f]+$/i.test(x)) return true; // don't treat 0123 as a number; as it drops the leading '0'.\n\n    if (x.length > 1 && x[0] === '0') return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n  }\n\n  function isUndefined(num) {\n    return num === undefined;\n  } // check user configuration settings for inconsistencies\n\n\n  function checkConfiguration() {\n    // count keys should not be set as array/narg\n    Object.keys(flags.counts).find(key => {\n      if (checkAllAliases(key, flags.arrays)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n        return true;\n      } else if (checkAllAliases(key, flags.nargs)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n        return true;\n      }\n    });\n  }\n\n  return {\n    argv: Object.assign(argvReturn, argv),\n    error: error,\n    aliases: Object.assign({}, flags.aliases),\n    newAliases: Object.assign({}, newAliases),\n    defaulted: Object.assign({}, defaulted),\n    configuration: configuration\n  };\n} // if any aliases reference each other, we should\n// merge them together.\n\n\nfunction combineAliases(aliases) {\n  const aliasArrays = [];\n  const combined = Object.create(null);\n  let change = true; // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  }); // combine arrays until zero changes are\n  // made in an iteration.\n\n  while (change) {\n    change = false;\n\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  } // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    combined[aliasArray.pop()] = aliasArray;\n  });\n  return combined;\n} // this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\n\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n\nfunction Parser(args, opts) {\n  const result = parse(args.slice(), opts);\n  return result.argv;\n} // parse arguments and return detailed\n// meta information, aliases, etc.\n\n\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts);\n}; // TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\n\n\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\n\nmodule.exports = Parser;","map":{"version":3,"names":["camelCase","require","decamelize","path","tokenizeArgString","util","parse","args","opts","Object","assign","create","aliases","combineAliases","alias","configuration","defaults","default","configObjects","envPrefix","notFlagsOption","notFlagsArgv","newAliases","defaulted","__","format","flags","arrays","bools","strings","numbers","counts","normalize","configs","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","array","filter","Boolean","forEach","opt","key","assignment","map","boolean","string","number","pop","push","count","narg","k","coerce","Array","isArray","config","extendAliases","error","checkConfiguration","notFlags","argv","_","argvReturn","i","length","arg","broken","letters","m","next","value","isUnknownOptionAsArg","match","checkAllAliases","eatArray","eatNargs","setArg","undefined","test","defaultValue","slice","split","j","maybeCoerceNumber","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","includes","prop","join","argAfterEqualSign","ii","toEat","isNaN","isUndefined","Error","available","consumed","Math","min","argsToSet","nargsCount","defVal","processValue","val","addNewAlias","splitKey","setKey","x","a","shift","defineProperty","enumerable","get","set","substring","v","increment","shouldCoerceNumber","isNumber","Number","isSafeInteger","floor","configLookup","configKey","configPath","resolvedConfigPath","resolve","process","cwd","e","setConfigObject","ex","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","applied","Set","has","ali","add","err","indexOf","obj","canLog","o","index","sanitizeKey","isTypeArray","isValueArray","duplicate","c","y","flag","toCheck","setAlias","find","hasAnyFlag","some","hasFlagsMatching","patterns","pattern","hasAllShortFlags","hasAllFlags","isUnknownOption","flagWithEquals","normalFlag","flagEndingInHyphen","flagEndingInDigits","flagEndingInNonWordCharacters","defaultForType","guessType","type","def","num","aliasArrays","combined","change","intersect","splice","aliasArray","self","orig","Parser","result","detailed","module","exports"],"sources":["/home/portuga/trybe-projetos/sd-021-b-project-trybewallet/node_modules/yargs/node_modules/yargs-parser/index.js"],"sourcesContent":["const camelCase = require('camelcase')\nconst decamelize = require('decamelize')\nconst path = require('path')\nconst tokenizeArgString = require('./lib/tokenize-arg-string')\nconst util = require('util')\n\nfunction parse (args, opts) {\n  opts = Object.assign(Object.create(null), opts)\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n\n  // aliases might have transitive relationships, normalize this.\n  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias))\n  const configuration = Object.assign({\n    'boolean-negation': true,\n    'camel-case-expansion': true,\n    'combine-arrays': false,\n    'dot-notation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'greedy-arrays': true,\n    'halt-at-non-option': false,\n    'nargs-eats-options': false,\n    'negation-prefix': 'no-',\n    'parse-numbers': true,\n    'populate--': false,\n    'set-placeholder-key': false,\n    'short-option-groups': true,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration)\n  const defaults = Object.assign(Object.create(null), opts.default)\n  const configObjects = opts.configObjects || []\n  const envPrefix = opts.envPrefix\n  const notFlagsOption = configuration['populate--']\n  const notFlagsArgv = notFlagsOption ? '--' : '_'\n  const newAliases = Object.create(null)\n  const defaulted = Object.create(null)\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  const __ = opts.__ || util.format\n  const flags = {\n    aliases: Object.create(null),\n    arrays: Object.create(null),\n    bools: Object.create(null),\n    strings: Object.create(null),\n    numbers: Object.create(null),\n    counts: Object.create(null),\n    normalize: Object.create(null),\n    configs: Object.create(null),\n    nargs: Object.create(null),\n    coercions: Object.create(null),\n    keys: []\n  }\n  const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/\n  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    const key = opt.key || opt\n\n    // assign to flags[bools|strings|numbers]\n    const assignment = Object.keys(opt).map(function (key) {\n      return ({\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      })[key]\n    }).filter(Boolean).pop()\n\n    // assign key to be coerced\n    if (assignment) {\n      flags[assignment][key] = true\n    }\n\n    flags.arrays[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n    flags.keys.push(key)\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n    flags.keys.push(k)\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n    flags.keys.push(k)\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  let error = null\n  checkConfiguration()\n\n  let notFlags = []\n\n  const argv = Object.assign(Object.create(null), { _: [] })\n  // TODO(bcoe): for the first pass at removing object prototype  we didn't\n  // remove all prototypes from objects returned by this API, we might want\n  // to gradually move towards doing so.\n  const argvReturn = {}\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]\n    let broken\n    let key\n    let letters\n    let m\n    let next\n    let value\n\n    // any unknown option (except for end-of-options, \"--\")\n    if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n      argv._.push(arg)\n    // -- separated by =\n    } else if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // arrays format = '--f=a b c'\n      if (checkAllAliases(m[1], flags.arrays)) {\n        i = eatArray(i, m[1], args, m[2])\n      } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n        // nargs format = '--f=monkey washing cat'\n        i = eatNargs(i, m[1], args, m[2])\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1]\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false)\n\n    // -- separated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      if (checkAllAliases(key, flags.arrays)) {\n        // array format = '--foo a b c'\n        i = eatArray(i, key, args)\n      } else if (checkAllAliases(key, flags.nargs) !== false) {\n        // nargs format = '--foo a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        i = eatNargs(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultValue(key))\n        }\n      }\n\n    // dot-notation flag separated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultValue(key))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '-f=a b c'\n            i = eatArray(i, key, args, value)\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '-f=monkey washing cat'\n            i = eatNargs(i, key, args, value)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultValue(letters[j]))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        if (checkAllAliases(key, flags.arrays)) {\n          // array format = '-f a b c'\n          i = eatArray(i, key, args)\n        } else if (checkAllAliases(key, flags.nargs) !== false) {\n          // nargs format = '-f a b c'\n          // should be truthy even if: flags.nargs[key] === 0\n          i = eatNargs(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultValue(key))\n          }\n        }\n      }\n    } else if (arg.match(/^-[0-9]$/) &&\n      arg.match(negative) &&\n      checkAllAliases(arg.slice(1), flags.bools)) {\n      // single-digit boolean alias, e.g: xargs -0\n      key = arg.slice(1)\n      setArg(key, defaultValue(key))\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1)\n      break\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i)\n      break\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg))\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults, true)\n  applyCoercions(argv)\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key]\n    })\n  }\n\n  if (configuration['strip-aliased']) {\n    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]\n      }\n\n      delete argv[alias]\n    })\n  }\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args, argAfterEqualSign) {\n    let ii\n    let toEat = checkAllAliases(key, flags.nargs)\n    // NaN has a special meaning for the array type, indicating that one or\n    // more values are expected.\n    toEat = isNaN(toEat) ? 1 : toEat\n\n    if (toEat === 0) {\n      if (!isUndefined(argAfterEqualSign)) {\n        error = Error(__('Argument unexpected for: %s', key))\n      }\n      setArg(key, defaultValue(key))\n      return i\n    }\n\n    let available = isUndefined(argAfterEqualSign) ? 0 : 1\n    if (configuration['nargs-eats-options']) {\n      // classic behavior, yargs eats positional and dash arguments.\n      if (args.length - (i + 1) + available < toEat) {\n        error = Error(__('Not enough arguments following: %s', key))\n      }\n      available = toEat\n    } else {\n      // nargs will not consume flag arguments, e.g., -abc, --foo,\n      // and terminates when one is observed.\n      for (ii = i + 1; ii < args.length; ii++) {\n        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++\n        else break\n      }\n      if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\n    }\n\n    let consumed = Math.min(available, toEat)\n    if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n      setArg(key, argAfterEqualSign)\n      consumed--\n    }\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + consumed)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args, argAfterEqualSign) {\n    let argsToSet = []\n    let next = argAfterEqualSign || args[i + 1]\n    // If both array and nargs are configured, enforce the nargs count:\n    const nargsCount = checkAllAliases(key, flags.nargs)\n\n    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n      argsToSet.push(true)\n    } else if (isUndefined(next) ||\n        (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults[key] !== undefined) {\n        const defVal = defaults[key]\n        argsToSet = Array.isArray(defVal) ? defVal : [defVal]\n      }\n    } else {\n      // value in --option=value is eaten as is\n      if (!isUndefined(argAfterEqualSign)) {\n        argsToSet.push(processValue(key, argAfterEqualSign))\n      }\n      for (let ii = i + 1; ii < args.length; ii++) {\n        if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n          (nargsCount && argsToSet.length >= nargsCount)) break\n        next = args[ii]\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break\n        i = ii\n        argsToSet.push(processValue(key, next))\n      }\n    }\n\n    // If both array and nargs are configured, create an error if less than\n    // nargs positionals were found. NaN has special meaning, indicating\n    // that at least one value is required (more are okay).\n    if ((nargsCount && argsToSet.length < nargsCount) ||\n        (isNaN(nargsCount) && argsToSet.length === 0)) {\n      error = Error(__('Not enough arguments following: %s', key))\n    }\n\n    setArg(key, argsToSet)\n    return i\n  }\n\n  function setArg (key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      const alias = key.split('.').map(function (prop) {\n        return camelCase(prop)\n      }).join('.')\n      addNewAlias(key, alias)\n    }\n\n    const value = processValue(key, val)\n    const splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        const a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        // populate alias only if is not already an alias of the full key\n        // (already populated above)\n        if (!(flags.aliases[key] || []).includes(x.join('.'))) {\n          setKey(argv, x, value)\n        }\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      const keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        Object.defineProperty(argvReturn, key, {\n          enumerable: true,\n          get () {\n            return val\n          },\n          set (value) {\n            val = typeof value === 'string' ? path.normalize(value) : value\n          }\n        })\n      })\n    }\n  }\n\n  function addNewAlias (key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias]\n      newAliases[alias] = true\n    }\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key)\n    }\n  }\n\n  function processValue (key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' &&\n      (val[0] === \"'\" || val[0] === '\"') &&\n      val[val.length - 1] === val[0]\n    ) {\n      val = val.substring(1, val.length - 1)\n    }\n\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    let value = Array.isArray(val)\n      ? val.map(function (v) { return maybeCoerceNumber(key, v) })\n      : maybeCoerceNumber(key, val)\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  function maybeCoerceNumber (key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\n        Number.isSafeInteger(Math.floor(value))\n      )\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    const configLookup = Object.create(null)\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      const configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          let config = null\n          const resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      const value = config[key]\n      const fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    const prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        const keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    let coerce\n    const applied = new Set()\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions)\n        if (typeof coerce === 'function') {\n          try {\n            const value = maybeCoerceNumber(key, coerce(argv[key]))\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n              applied.add(ali)\n              argv[ali] = value\n            })\n          } catch (err) {\n            error = err\n          }\n        }\n      }\n    })\n  }\n\n  function setPlaceholderKeys (argv) {\n    flags.keys.forEach((key) => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults, canLog = false) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n        if (canLog) defaulted[key] = true\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    let o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    const key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    let o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key)\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {}\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({})\n        } else {\n          o[key] = [o[key], {}]\n        }\n\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\n        o = o[key][o[key].length - 1]\n      } else {\n        o = o[key]\n      }\n    })\n\n    // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n    const key = sanitizeKey(keys[keys.length - 1])\n\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    const isValueArray = Array.isArray(value)\n    let duplicate = configuration['duplicate-arguments-array']\n\n    // nargs has higher priority than duplicate\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true\n      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n        o[key] = undefined\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(\n      o[key] === undefined ||\n        checkAllAliases(key, flags.counts) ||\n        checkAllAliases(key, flags.bools)\n    )) {\n      o[key] = [o[key], value]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases (...args) {\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            const c = camelCase(x)\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        // For \"--optionName\", also set argv['option-name']\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            const c = decamelize(x, '-')\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // return the 1st set flag for any of a key's aliases (or false if no flag set)\n  function checkAllAliases (key, flag) {\n    const toCheck = [].concat(flags.aliases[key] || [], key)\n    const keys = Object.keys(flag)\n    const setAlias = toCheck.find(key => keys.includes(key))\n    return setAlias ? flag[setAlias] : false\n  }\n\n  function hasAnyFlag (key) {\n    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]))\n    return toCheck.some(function (flag) {\n      return Array.isArray(flag) ? flag.includes(key) : flag[key]\n    })\n  }\n\n  function hasFlagsMatching (arg, ...patterns) {\n    const toCheck = [].concat(...patterns)\n    return toCheck.some(function (pattern) {\n      const match = arg.match(pattern)\n      return match && hasAnyFlag(match[1])\n    })\n  }\n\n  // based on a simplified version of the short flag group parsing logic\n  function hasAllShortFlags (arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }\n    let hasAllFlags = true\n    let next\n    const letters = arg.slice(1).split('')\n    for (let j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2)\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false\n        break\n      }\n\n      if ((letters[j + 1] && letters[j + 1] === '=') ||\n        next === '-' ||\n        (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n        (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n        break\n      }\n    }\n    return hasAllFlags\n  }\n\n  function isUnknownOptionAsArg (arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg)\n  }\n\n  function isUnknownOption (arg) {\n    // ignore negative numbers\n    if (arg.match(negative)) { return false }\n    // if this is a short option group and all of them are configured, it isn't unknown\n    if (hasAllShortFlags(arg)) { return false }\n    // e.g. '--count=2'\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/\n    // e.g. '-a' or '--arg'\n    const normalFlag = /^-+([^=]+?)$/\n    // e.g. '-a-'\n    const flagEndingInHyphen = /^-+([^=]+?)-$/\n    // e.g. '-abc123'\n    const flagEndingInDigits = /^-+([^=]+?\\d+)$/\n    // e.g. '-a/usr/local'\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/\n    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)\n  }\n\n  // make a best effor to pick a default value\n  // for an option based on name and type.\n  function defaultValue (key) {\n    if (!checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts) &&\n        `${key}` in defaults) {\n      return defaults[key]\n    } else {\n      return defaultForType(guessType(key))\n    }\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    const def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key) {\n    let type = 'boolean'\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.bools)) type = 'boolean'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n    return type\n  }\n\n  function isNumber (x) {\n    if (x === null || x === undefined) return false\n    // if loaded from config, may already be a number.\n    if (typeof x === 'number') return true\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (x.length > 1 && x[0] === '0') return false\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  // check user configuration settings for inconsistencies\n  function checkConfiguration () {\n    // count keys should not be set as array/narg\n    Object.keys(flags.counts).find(key => {\n      if (checkAllAliases(key, flags.arrays)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key))\n        return true\n      } else if (checkAllAliases(key, flags.nargs)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key))\n        return true\n      }\n    })\n  }\n\n  return {\n    argv: Object.assign(argvReturn, argv),\n    error: error,\n    aliases: Object.assign({}, flags.aliases),\n    newAliases: Object.assign({}, newAliases),\n    defaulted: Object.assign({}, defaulted),\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  const aliasArrays = []\n  const combined = Object.create(null)\n  let change = true\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  const result = parse(args.slice(), opts)\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey (key) {\n  if (key === '__proto__') return '___proto___'\n  return key\n}\n\nmodule.exports = Parser\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}